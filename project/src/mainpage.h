 /*!
 * @file mainpage.h
 * @copyright 2019 3081 Staff, All rights reserved.
 * \mainpage BusSimulation Project for CSCI 3081w
 *
 * \section Overview
 * The purpose of this project is to enhance a simple bus simulator throughout each iteration. The bus simulation obtains information from the configuration
 * and information is displayed on a graphic windows by web server. For iteration 1, I have added a new class bus_factory that generates three different types of buses by size
 * and for this iteration 1 busType is decided by a random number generator. Also, the pause/resume function is added on the web server in order to pause the simulation whenever a user desires to and resume again.
 * Whenever a bus's next stop does not have any passengers waiting at the stop and has no passenger to unload on next s top, print statment will print out busId and stopId.
 * Every header and source file in src folder has been checked by the Google Style Compilance in iteration 1, and a new route has been added in config.txt
 *
 * \section intro_sec Introduction - How to compile the program and run the simulation
 *
 * There are two steps that need to be processed in order to run the bus simulation. First step is the compilation. In this step, a user needs to navigate to the base project directory. Once, the user has successfully navigated to the base project directory. Then, the user can navigate to the src folder which is inside the project directory and type out the command “make”. The “make” command will compile all the header and source files inside the project directory, and if the compilation
 * successfully finishes, it will link to the server. Then, the user needs to navigate back to the previous directory and type “./build/bin/vis_sim <port number>”. By typing this, the web server is successfully linked and is able to run the server on the web browser. Port number should be a number above 8000 and the last three digits can be achieved by the user’s student number id. For instance, if the last three digits of the student ID number is 736, the port number should be 8736. Then, the * user can open up the internet browser on either vole or CSE lab machine, and enter the following address (http://127.0.0.1:<port number>/web_graphics/project.html) in the address bar of the web browser.
 * In order to compile and run unit tests created with google test, the user needs to navigate to the base project directory. Once, the user has successfully navigated to the base project directory. Then, the user can navigate to the tests folder and type out the command “make”. The “make” will compile every test file unless there is any compilation error. Then, the user can type out “../build/bin/unittest” which will print out the result of all the unit tests.
 * In order to check the google style compliance in the project directory, the user can simply type “[path_to_cpplint]/cpplint/cpplint-cse.sh --root=[path_target_dir][file_name]”.
 *
 * \section body_sec Implmentation Of BusFactory - Abstract or Concrete
 * There are two ways you can implement the busfactory. One way of implementation is to implement it abstractly. Abstract bus factory is a hierarchy factory that can create other factories. In this project, abstract bus factory can have child factory classes that can produce an object of each type of bus. Whereas in concrete bus factory class, a specific type of a bus object can be produced directly from the concrete bus factory.
 * For this project, I used the concrete bus factory implementation because there is no need of making sub factories for just three different types of bus. I would definitely consider implementing an abstract bus factory if there are more types of bus that deal with diverse patterns. However, the only difference among three different types of bus is the capacity so I chose to implement the concrete bus factory in order to keep the code straightforward. One of the pros for the concrete bus
 * factory is high cohesion of the code. High cohesion means that a group of code related to each other can be bonded as one big group of code. Contradictory, this can result in high cohesion and high coupling when a user insists on implementing the concrete bus factory creating various objects. Basically, one big strand of code is forced to handle creating different objects, breaking down the advantage of concrete factory. Cons is the lack of flexibility of types of class that can be
 * abstractly generated which enables the low coupling.
 * Pros for an abstract bus factory is that it gives a solid framework on how each subclass should be generated. For example, a small_bus_factory that inherits abstract_bus_factory has a solid framework to produce an object of small bus class resulting in low coupling. Cons for abstract bus factory would be a situation called destructive decoupling. Destructive decoupling happens when a group of code is separated from each other too much and loses the clearance of the code.
 *
 * \section body2_sec New Classes and methods Added In Iteration - 2
 * Description of new classes and how new methods are implemented is listed below.
 * New class IObserver has a virtual function called Notify(). This Notify(BusData* Info) function is invoked every time NotifyObserver(BusData* Info) function in IObservable class is called and puts  the bus information in a string which gets displayed on the web browser.
 * IObservable class has a private vector variable of IObserver pointer. RegisterObserver(IObserver* bus_) function puts an observer pointer into the list. ClearObserver() goes through the loop iteration to clear every observer in the list.
 * BusWebObserver class inherits IObserver class and overrides Notify(BusData* Info) function in order to get the bus data, put that data into a string, and send it to the browser.
 *AddListener(std::string id, IObserver* observer) and ClearListeners() functions have been added in iteration 2. AddListener function takes a string and observer in the parameter and uses a loop that iterates up to busses_ list size to find the given id in busses and if the given id is found, then busses_[i] calls RegisterObserver(observer) to add the observer in the list and busses_[i] calls Update() function. I have changed bus class to inherit IObservable and modified the Update() function  * in bus class in order to invoke NotifyObserver(BusData* Info). ClearListeneres() function runs a loop that iterates upto the size of busses_ list. Each iteration busses_[i] calls ClearObserver() to remove the observer.
 * BusFactory::GenerateBus(std::string id, Route* outbound, Route* inbound, double speed) has been modified to use the deployment strategy. I have added three static int variables in the BusFactory class to keep track of state. Instead of generating a random bus in iteration 1, I have commented out the random number generator and included <time.h>. Int hour = aTime->tm_hour keeps track of current local time and three strategies were used in specific time. If none of the strategies was used, it *automatically returns a small bus. I used modulus to keep track of the state for each strategy.
 *
 * \section body3_sec Designing and Implementing the Observer Pattern
 * Design
 * In order to implement the Observer Pattern, I have added 4 new classes in Iteration 2 (IObserver, IObservable, BusWebObserver, AddListenerCommand). I will go through each class and explain how I implemented the code. First, I created IObserver class as an abstract class, and IObserver has a virtual function called Notify(BusData* Info) that can be overridden by the child class. BusWebObserver is the concrete observer class in my code. It override the Notify(BusData* Info) to put the bus data * into a string and send it to the GUI. IObservable class is the Subject class. It has a private variable called list that contains IObserver pointers in vector. The list keeps track of all the observers that are observing busses.
 * For graphic design, I have copied code from the lab 14 file which detects a user’s mouse click on the bus presented in the simulation. Whenever a click is detected on the bus, socket sends a command called ‘listen’ with a bus id. From this point, AddListenerCommand class is implemented in order to be called out whenever sketch.js sends the ‘listen’ command. AddListenerCommand class function execute() calls ClearListeners() first to clear out all the observers in the list and calls *AddListener(std::string id, IObserver* observer) to find the id in busses and observe the bus. AddListener(std::string id, IObserver* observer) calls the bus’s Update function which invokes NotifyObserver(BusData* Info) function to invoke Notify(BusData* Info) in the BusWebObserver class.
 * Pattern
 * The Observer Pattern has a back and forth distributed architecture.
 * JS -> Command -> VisSim -> Observable -> VisSim -> Command -> JS
 * First, sketch.js detects a click on the bus from the user. When a click is detected, it identifies the id of the bus and sends it to the command. AddListenerCommand gets executed to call mySim to clear every observer in the list. Then, it creates a new BusWebObserver pointer and mySim calls the AddListener which takes a bus id and BusWebObserver pointer. VisualSimulation looks for busses that contain the id. If the bus with the id is found, then the bus is updated. After notifying each *Observer, a string is created to deliver the bus data back to the WebServer. Once the sketch.js has successfully received the bus data, the bus data gets displayed on the webpage.
 *
 * \section body4_sec Docorator Pattern
 *Decorator pattern I have implemented in iteration 3 checks each bus of the current route whether it is out_going or in_going route. If it is the out_going_route, I have assigned the bus color to maroon by setting red to 150, green to 0,  and blue to 0 inside the UpdateBusData function. I have added another color gold inside the if condition loop in the UpdateBusData function. It checks if the current route which gets set to out_going_route in the beginning has reached the end of the route. If * it did reach the end, then the current_route gets assigned to in_going_route and the color gets reassigned by setting red to 220, green to 200, and blue to 0. I have also implemented the color intensity of the bus based on its number of passengers. In the UpdateBusData function, the value of alpha gets assigned by num_of_passengers * 35 to illustrate the passenger intensity of the bus.
 *
 * \section body5_sec Two Alternate Decorator Patterns
 * One alternate decorator pattern is the route distinction pattern. In my simulation, I have added the campus east bank properties route and campus west bank properties route. Each different color can be assigned  by the name of route and the passenger intensity can be represented by the current number of passengers of the bus.
 * Another alternate decorator pattern can be the assignment of color by the type bus. In my bus simulation, the bus depot strategy of the bus factory produces each bus based on the time. Bus color can be represented in three colors for three types and the expected passenger intensity of the bus can be represented by the time.
 * One of the cons for these alternate decorator patterns is the high coupling. After adding new conditions for the decorator pattern, the dependency between classes would be high. Therefore, it would be hard to understand the code in isolation.
 * One of the pros for these alternate decorator patterns is the strong cohesion. By implementing a new class for a specific task with little interaction with another class can increase the cohesion. Therefore, it would make the members of code very distinct to viewers and the functionality can be grasphed easily.
 *
 * \section body6_sec Pros and Cons for my Decorator Patterns
 * One of the cons for my decorator pattern is the multiple of unnecessary color assignment in the UpdateBusData function. The color of the bus gets assigned even when there is no need of changing. Instead of assigning color everytime bus gets updated in one function, a new decorating class can check the bus’s current route and assign the color based on the result. This new class would remove unnecessary color assignment. By implementing the new class for a specific function, the code can be *high cohesion.
 * One of the pros for my decorator pattern is the easy access of each bus color data in the simulation. By assigning color in the UpdateBusData function, I can accumulate the bus color data and intensity data at the end of the simulation. By adding few more conditions in the preexisting code, the code can be low coupling.
 *
 * \section body7_ New Methods and CLasses Added in Itertation 3
 * FileWriteManger, FileWriter, and Util classes have been added in iteration 3 in order to produce two log files. The FileWriteManger class is the singleton class which has a static object pointer of FileWriter and it gets invoked only when the function getInstance in the FileWriteManager is called. The getLog function in the FileWriteManager receives the name of the file and strings that will be written in the file. Inside the getLog function, it will invoke the write function that receives a * string for the file name and datas that will be written in the file. In the FileWriter class, the write function returns a log file. The Util function takes an ostreamstring and it will parse the string by every space. Each separate string word gets stored in the string list and returns that list.
 * Stop_Web_Observer class has been added to observe a single stop. A new virtual fucntion called NotfiyStop has been added in the IObserver class. Since I couldn’t compile the virtual function with templates, I have added a new virtual function for stop instead of changing the code I had previously. In the IObservable class, a new function called NotfiyStopObserver(StopData*) has been added to invoke NotifyStop. I have added a new web server command AddStopListender. This would get invoked *whenever the stop gets clicked on the webpage which sends “listenS”. Then, in my simulator class, AddStopListener gets called. A new function ifContain(string id) checks if any of stops in the routes has the same id and if that is the case, observer gets registered and necessary information gets stored in a string and gets sent back to sketch.js for printing. In order to do this, the Route class now inherits the IObservable class.
 */
#ifndef SRC_MAINPAGE_H_
#define SRC_MAINPAGE_H_
#endif  // SRC_MAINPAGE_H_
